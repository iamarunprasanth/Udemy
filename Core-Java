primitive datatype: int, float, double, boolean, char, byte, long, short
Non Primitive datatype: They are objects - String. 
Diff b/w String and Stringbuilder 
String: It will replace the old text with new when appended.
StringBuilder: it will keep on adding the text when appended. 
StringBuilder sb = new StringBuilder();
sb.append("").append("");
While loop: Entry controlled loop
while(condition){
// do something
}
for loop: (initialization;condition;increment/decrement)
do-while loop: do{
                something
                }while(condition);
                
if(condition){
else if() {
// can have n number of if-else 
}
}else{
}
Switch(int n){
case 1
.
..
.
case n:
default{ // Optional.
}
Getting user input: we use Scanner class - Scanner scanner = new Scanner(System.in) -> refers to keyboard input.

Array is a class 
int[] intArray = new int[4];
intArray={1,2,3,4,4}
Multidimensional array:
int[][] multiArray = new int[3][3];
multiArray = {{1,2,3},{4,5,6}};
// Array.length most used func to get array length. 
Class : is a blue print contains state (instance variables) and behaviours (methods)
Methods: Certain behaviour.
Method Parameters: public void getInput(int a, int b) {} // parameters.
Method Arguments: are the value we pass on the method with parameters.
This keyword can be used to initialize the instance variables. 
Constructor - when an objject of a class is initialized, constructor will execute automatically. 
public CLASSA {
public CLASSA() {} // can have any number of parameters.
}
Static - keyword when used, the instance variable/metod can be accessed using the class directly. 
Static and FINAL - when used to initialize the constants and those value can't be changed through its life span.
toString() - used to print the obj.toString();
Inheritance - Parent class extends Child class - Child class can override all the properties of the parent class. 
A child class can extend to maximum of one parent class
Packages - are like folders to segregate the similar class types together, when a class from diff packages is accessed 
then package reference has to be imported. 
interfaces - unlike classes, they provide a template containing list of abstract methods (abstract keyword is optional)
can't have all sort of access modifiers - it is defaulted to public. 
A class can implement n number of interfaces. A interface cannot implement a interface 
Abstract class can implement an interface - won't throw error on compile time, 
since Objects cannot be created for Abstract classes and interfaces. 
but, when a normal class extends Abstract class implementing interface - It will throw a run time error. 
Public - can be accessible anywhere 
private - can be accessible only within the class 
protected - onluy be accessible withing the package and child class extending from other packages. 
Polymorphism - wherever the Parent class is initialized can be called with child reference as well. 
Encapsulation - Data hiding and abstraction. 
private String data;
//setters
public void getData(String data) {
this.data =data;
}
//getters
public String showData() {
return data;
}
Casting: When downcasting a higer reference, we need cast to lower ref.

Upcasting: 
Camera camera1;
Machine machine = camera1; // upcasting 
Machine machine1 = camera2;
Camera camera2=(Camera)machine1 // downcasting.

Machine machine4 = new Machine();
Camera camera5 = machine4; // this won't work, gives compile time error. 

Using Generics:
Till java 5 without Generics
ArrayList list = new ArrayList();
list.add("fruit")
String fruits = (String) list.get(0); // downcasting object to String. 
From java 6 using generics 
ArrayList<String> list = new ArrayList<String>(); // can able to provide type so that casting is not required.
From java 7 using generics
ArrayList<String> list = new ArrayList<>(); // type is not needed on Object creation 
Using wildcards on generics 

ArrayList<String> list = new ArrayList<? list>(); // ? is a wildcard, passing unkown object type. 
when we iterate this, we need to use Object type:list;
It can also extends any super class 
for ex: ArrayList<String> list = new ArrayList<?extends Machine list>();
then Machine type can be used to iterate instead of Object type to print Machine class related. 

Anonymous class:
class Machine{
public void start() {
syso("starting..");
}
public class App {
main(String args[]) {
Machine machine = new Machine(){ // Anonymous class -> Its a sub class of Machine class type but with no class name. 
@Override
public void start() {
syso("machine starting..");
}};
machine.start(); // will override the parent class implementation and display overriden. 
}}} // Anonymous class works for Interface and Abstract class as well.

Reading file using Scanner
1. capture the path of the file 
2. Using Scanner scanner = new Scanner(path)
3.while(scanner.hasNextLine()) // to read strings. use hasNext(to read int)
String line = scanner.nextLine();
syso(line);

Handling Exceptions in java
Using throws and try catch block for handling the exceptions.
Multiple exception try{}
catch(IOException|Exception){}finally{try[]catch{}} // finally executes on both the scenarios. 
Checked exceptions : forced to be handle - File , thread.sleep
Runtime exception: not forced to be handle, but when compiled throws an exception. 
1. dividing some number by 0 - Arithmetic exception
2. text.length - when text is not been declared with any value - Null pointer exception

Abstract class:
Its a kind of class unlike interfaces, object ref of the class can't be created. 
it can have abstract/normal methods. it can have instance variables, can have all sort of access modifiers. 
It can extend to one class and can extend from abstract/normal class.

Diff b/w Abstract class and interface
1. Abstract class can extend one class/abstract class at a time. can extend from one class/abstract class at a time.
2. Abstract class can have abstract/concrete methods.
3. In Abstract class - ABSTRACT keyword is mandatory 
4. abstract  class can have  protected , public and public abstract methods
5. abstract class can have  static, final  or static final  variable with any access specifier
1. Interfaces can implement to multiple classes/abstract classes. can implement from an interface only. 
2. Interface can have abstract method only (Abstract) keyword is optional.
3. Interface can have only public access specifier by default.
4. interface  can  have only static final (constant) variable i.e. by default

Reading file using FileReader: // can read only in bunch chars
so we have to use BufferedReader as well along with FileReader in order to read a complete line. 
then after reading we wil close the BufferedReader br.close(); // it will close br,fr,file.
To write to file use try(BufferedWriter bw = new BufferedWriter(new FileWriter(file)){
bw.write("asdasd");}
catch(Exception e){}
Try with Rescources : java-7
until java 6:
Temp temp = new Temp();
try{
temp.close();}
catch(Exception e) {
syso(e.getMessage());}
from java 7 using try with rescources:
try(Temp temp = new Temp()) {}
catch(Exception e) {
syso(e.getMessage());}
