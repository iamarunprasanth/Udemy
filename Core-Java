primitive datatype: int, float, double, boolean, char, byte, long, short
Non Primitive datatype: They are objects - String. 
Diff b/w String and Stringbuilder 
String: It will replace the old text with new when appended.
StringBuilder: it will keep on adding the text when appended. 
StringBuilder sb = new StringBuilder();
sb.append("").append("");
While loop: Entry controlled loop
while(condition){
// do something
}
for loop: (initialization;condition;increment/decrement)
do-while loop: do{
                something
                }while(condition);
                
if(condition){
else if() {
// can have n number of if-else 
}
}else{
}
Switch(int n){
case 1
.
..
.
case n:
default{ // Optional.
}
Getting user input: we use Scanner class - Scanner scanner = new Scanner(System.in) -> refers to keyboard input.

Array is a class 
int[] intArray = new int[4];
intArray={1,2,3,4,4}
Multidimensional array:
int[][] multiArray = new int[3][3];
multiArray = {{1,2,3},{4,5,6}};
// Array.length most used func to get array length. 
Class : is a blue print contains state (instance variables) and behaviours (methods)
Methods: Certain behaviour.
Method Parameters: public void getInput(int a, int b) {} // parameters.
Method Arguments: are the value we pass on the method with parameters.
This keyword can be used to initialize the instance variables. 
Constructor - when an objject of a class is initialized, constructor will execute automatically. 
public CLASSA {
public CLASSA() {} // can have any number of parameters.
}
Static - keyword when used, the instance variable/metod can be accessed using the class directly. 
Static and FINAL - when used to initialize the constants and those value can't be changed through its life span.
toString() - used to print the obj.toString();
Inheritance - Parent class extends Child class - Child class can override all the properties of the parent class. 
A child class can extend to maximum of one parent class
Packages - are like folders to segregate the similar class types together, when a class from diff packages is accessed 
then package reference has to be imported. 
interfaces - unlike classes, they provide a template containing list of methods 
A class can implement n number of interfaces. A interface cannot implement a interface 
Abstract class can implement an interface - won't throw error on compile time, 
since Objects cannot be created for Abstract classes and interfaces. 
but, when a normal class extends Abstract class implementing interface - It will throw a run time error. 
Public - can be accessible anywhere 
private - can be accessible only within the class 
protected - onluy be accessible withing the package and child class extending from other packages. 
Polymorphism - wherever the Parent class is initialized can be called with child reference as well. 
Encapsulation - Data hiding and abstraction. 
private String data;
//setters
public void getData(String data) {
this.data =data;
}
//getters
public String showData() {
return data;
}
Casting: When downcasting a higer reference, we need cast to lower ref.

Upcasting: 
Camera camera1;
Machine machine = camera1; // upcasting 
Machine machine1 = camera2;
Camera camera2=(Camera)machine1 // downcasting.

Machine machine4 = new Machine();
Camera camera5 = machine4; // this won't work, gives compile time error. 

Using Generics:
Till java 5 without Generics
ArrayList list = new ArrayList();
list.add("fruit")
String fruits = (String) list.get(0); // downcasting object to String. 
From java 6 using generics 
ArrayList<String> list = new ArrayList<String>(); // can able to provide type so that casting is not required.
From java 7 using generics
ArrayList<String> list = new ArrayList<>(); // type is not needed on Object creation 
Using wildcards on generics 

ArrayList<String> list = new ArrayList<? list>(); // ? is a wildcard, passing unkown object type. 
when we iterate this, we need to use Object type:list;
It can also extends any super class 
for ex: ArrayList<String> list = new ArrayList<?extends Machine list>();
then Machine type can be used to iterate instead of Object type to print Machine class related. 

Anonymous class:
class Machine{
public void start() {
syso("starting..");
}
public class App {
main(String args[]) {
Machine machine = new Machine(){ // Anonymous class -> Its a sub class of Machine class type but with no class name. 
@Override
public void start() {
syso("machine starting..");
}};
machine.start(); // will override the parent class implementation and display overriden. 
}}} // Anonymous class works for Interface and Abstract class as well.

Reading file using Scanner
1. capture the path of the file 
2. Using Scanner scanner = new Scanner(path)
3.while(scanner.hasNextLine()) // to read strings. use hasNext(to read int)
String line = scanner.nextLine();
syso(line);


